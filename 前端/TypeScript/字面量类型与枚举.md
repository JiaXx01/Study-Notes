# 字面量类型与联合类型

```ts
interface IRes {
  code: 1000 | 1001 | 5000
  status: 'success' | 'failure'
  data: any
}
```

## 字面量类型

`status`的两个类型`success`、`failure`就是字面量类型，在TypeScript中代表着比原始类型更精确的类型，同时也是原始类型的字类型，字面量类型主要包括`字符串字面量类型、数字字面量类型、布尔字面量类型、对象字面量类型`

```ts
const str: 'abc' = 'abc'
const num: 100 = 100
const bool: true = true

// 对象字面量类型
interface User = {
  name: 'JiaX',
  age: number
}
const user: User = {
  name: 'JiaX',
  age: 23
}
```

原始类型要求类型相同，字面量类型要求值相同；要实现一个对象字面量类型，就需要完全实现该类型的每一个属性的每一个值

## 联合类型

字面量类型单独使用并没有什么意义，通常是与联合类型一起使用；联合类型代表`类型的可用集合`，只要赋值的类型属于联合类型的成员之一，就符合这个联合类型

```ts
type oneAndTwo = 1 | 2
type union = true | string | 12 | (() => {}) | oneAndTwo
```

- 联合类型中的函数类型需要使用括号`()`包裹起来，函数没有字面量类型`(() => {})`就是一个函数类型
- 联合类型可以嵌套其他的联合类型，所有嵌套的联合类型都会被展开到同一级

可以通过联合类型，将多个对象的类型联合实现对象属性的互斥

```ts
type User =
  | {
      vip: true
      expires: string
    }
  | {
      vip: false
      promotion: string
    }
```

将vip类型定义为布尔字面量类型，在实际使用中通过判断vip的属性为`true`或`false`，接下来的类型推导就会缩窄到对应的联合类型分支之中

# 枚举

枚举是TypeScript新增的一种数据结构和类型，它既是值也是类型，在编译为JavaScript后会转为对象；枚举可以认为是对`对象类型`对扩展

```ts
const _pageUrl = {
  Home: '/home',
  About: '/about',
  Setting: '/setting',
}
// 枚举
enum PageUrl {
  Home = '/home',
  About = '/about',
  Setting = '/setting',
}

const homeUrl = PageUrl.Home
```

使用枚举定义常量，可以将常量限定在特定的容器或命名空间中，同时能够得到更好的类型提示

如果没有声明枚举的之，默认使用数字枚举；从0开始，以1递增；

```ts
enum Items {
  Foo, // 0
  Bar, // 1
  Baz, // 2
}
```

如果只为某个成员指定枚举值，在该成员之前的值依旧是从0递增，之后的值从该枚举值递增；如果该枚举值非数字，那么该成员之后的所有成员都需要指定枚举值

```ts
enum Items {
  Foo, // 0
  Bar, // 1
  Baz = 10,
  Qux, // 11
}

enum Items2 {
  Foo, // 0
  Bar, // 1
  Baz = 'baz',
  Qux = 'qux', // 如果没有指定会提示“Enum member must have initializer”
}
```

在数字型枚举中，可以使用延迟求值的枚举值，比如函数；如果使用了延迟求值，那么没有指定枚举值的成员必须放在最开头的位置，或者放在使用常量枚举值声明的成员之后

```ts
const returnNum = () => 100 + 499
enum Items {
  Foo, // 0
  Bar = returnNum(), // 599
  Baz = 10,
  Qux, // 11
}
```

**枚举和对象的重要区别，对象是单向映射的，只能从键映射到值；而枚举是双向映射到，可以从枚举成员映射到枚举值，也可以从枚举值映射到枚举成员**
**只有值为数字的枚举成员才会进行双向映射， 值不为数字的枚举成员仍是单向映射**

```ts
enum Items {
  Foo,
  Bar,
  Baz,
}

const fooValue = Items.Foo // 0
const fooKey = Items[0] // "Foo"
```
