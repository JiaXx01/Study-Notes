# 函数

## 函数的类型签名

变量的类型描述了变量的值的类型，函数的类型就是描述函数的入参和返回值的类型

可以通过多种方式声明函数类型

```ts
const fun = function (name: string): number {
  return name.length
}

const fun1: (name: string) => number = function (name) {
  return name.length
}

const fun2 = (name: string): number => {
  return name.length
}

const fun3: (name: string) => number = (name) => {
  return name.length
}

type Fun4 = (name: string) => number
const fun4: Fun4 = (name) => {
  return name.length
}

interface Fun5 {
  (name: string): number
}
const fun5: Fun5 = (name) => {
  return name.length
}
```

## 可选参数

在函数声明中使用`?`描述一个可选参数，可选参数必须位于必选参数之后，如果为可选参数声明了默认值不能在使用`?`

```ts
function fun(name: string, age?: number) {
  // age 类型为 number | undefined 联合类型
  ...
}

function fun2(name: string, age: number = 18) {
  // ': number'可省略，age会自动推导为number
}
```

## 函数重载

在某些逻辑复杂的情况起下，函数可能有多种入参类型和返回值类型

```ts
function func(foo: number, bar?: boolean): string | number {
  if (bar) {
    return String(foo)
  } else {
    return foo * 100
  }
}
```

上面的代码中，函数的返回值的类型基于bar传人的值，bar为`true`函数返回值类型为`string`；bar为`false`或`undefined`，函数返回值类型为`number`；而函数的类型签名并没有体现这一点，只知道函数的返回类型是一个`string | number`联合类型

函数的重载签名就能够实现入参类型与返回值类型相关联

```ts
function fun(foo: number, bar: true): string
function fun(foo: number, bar?: false): number
function fun(foo: number, bar?: boolean): string | number {
  if (bar) {
    return String(foo)
  } else {
    return foo * 100
  }
}

fun(100, true) // string
fun(100) // number
fun(100, false) // number
```

三个不同的`function fun`有不同的意义

- `function fun(foo: number, bar: true): string`函数的重载签名一，传入`bar`的值为`true`时，函数返回值为`string`类型
- `function fun(foo: number, bar?: false): number`函数的重载签名二，传入`bar`的值为`false`或不传时，函数返回值为`number`类型
- `function fun(foo: number, bar?: boolean): string | number`函数的实现签名，包含所有重载签名的可能的情况

## 异步函数、Generate函数

```ts
async function asyncFun(): Promise<void> {}

function* genFun(): Iterable<void> {}

async function* asyncGenFun(): AsyncIterable<void> {}
```

# 类

## 类与类成员的类型声明

类的主要结构有`构造函数、属性、方法、修饰符`；属性的类型标注类似于变量，构造函数、方法、getter、setter的类型标注类似于函数

```ts
class Foo {
  prop: string

  constructor(prop: string) {
    this.name = name
  }

  print(addon: string): void {
    console.log(`${this.prop} and ${addon}`)
  }

  get propA(): string {
    return `${this.prop}A`
  }

  set propA(value: string) {
    this.prop = value
  }
}
```

`setter`**方法不允许进行返回值的标注**，类的方法也可以进行函数重载

## 修饰符

在TypeScript中，能够为类成员添加以下修饰符`public、private、protected、readonly`；除了`readonly`外，其他三个都属于访问性修饰符，`readonly`属于操作性修饰符

```ts
class Foo {
  private prop: string

  constructor(prop: string) {
    this.name = name
  }

  protected print(addon: string): void {
    console.log(`${this.prop} and ${addon}`)
  }

  public get propA(): string {
    return `${this.prop}+A`
  }

  // 类的成员没有显示使用修饰符时，默认为public
  set propA(value: string) {
    this.prop = value
  }
}

const foo = new Foo('bar')
console.log(foo.propA) // 'bar+A'
foo.propA = 'baz'
console.log(foo.propA) // 'baz+A'
```

不同修饰符的意义

- `public`：此类成员在类、类的实例、子类中都能被访问
- `private`：此成员只能在类的内部访问，类的实例和子类无法访问
- `protected`：此成员仅能在类与子类中访问，类的实例无法访问

上面的代码中，要给类的属性进行赋值需要先声明类的属性，然后在构造函数中赋值，这种方式比较麻烦；还可以在构造函数中对参数应用访问性修饰符

```ts
class Foo (
  constructor(public arg1: string, private arg2: boolean) ()
)

new Foo('bar', true)
```

## 静态成员

使用`static`标识一个成员为静态成员

```ts
class Foo {
  static staticHandler() {}

  instanceHandler() {}
}
```

静态成员在类中无法使用`this.staticHandler`进行访问，只能使用`Foo.staticHandler`进行访问；

将上面的代码转为es5的代码

```ts
var Foo = function () {}
Foo.staticHandler = function () {}
Foo.prototype.instanceHandler = function () {}
```

可以看到，**静态成员会挂载在函数体上，实例成员会挂载在原型上；静态成员不会被实例继承，它只属于当前定义的类以及其子类；原型对象上的实例成员会沿着原型链进行传递，能够被继承**

## 继承、实现、抽象类

使用`extends`关键字实现类的继承

```ts
class Base {}

class Derived extends Base {}
```

上面的两个类，就是所说的`父类`与`子类`，或者可以称为`基类`和`派生类`

派生类中可以访问到基类中使用`public`和`protected`修饰的成员，也可以在派生类中覆盖基类的方法，但是仍然可以使用`super`访问到基类的方法

```ts
class Base {
  print() {}
}

class Derived extends Base {
  print() {
    super.print()
    // ...
  }
}
```

在派生类中覆盖基类的方法时，为了确保基类中存在该方法，需要使用`override`来确保派生类要覆盖的方法在基类中存在

```ts
class Base {
  printNoExist() {}
}

class Derived extends Base {
  override print() {
    // 报错，“This member cannot have an 'override' modifier because it is not declared in the base class 'Base'”
    // ...
  }
}
```

除了基类与抽象类以外，还有一个重要的概念`抽象类`，抽象类是对类结构与方法的抽象，**抽象类描述了一个类中需要有哪些成员，抽象方法描述了类中的方法的入参类型与返回值类型**，抽象方法类似于一个函数的类型签名，抽象类和内部成员都使用`abstract`关键字声明

```ts
abstract class AbsFoo {
  abstract absProp: string
  abstract get absGetter(): string
  abstract absMethod(name: string): string
}
```

使用`implement`实现一个抽象类

```ts
class Foo implements AbsFoo {
  absProp: string = 'abs'

  get absGetter() {
    return 'abs'
  }

  absMethod(name: string) {
    return name
  }
}
```

**不能声明静态的抽象成员**

抽象类的本质就是声明一个类的结构，所以也可以使用`instance`

```ts
interface FooStruct {
  absProp: string
  get absGetter(): string
  absMethod(input: string): string
}

class Foo implements FooStruct {
  absProp: string = 'struct'

  get absGetter() {
    return 'struct'
  }

  absMethod(name: string) {
    return name
  }
}
```
