TypeScript内置的工具类型，按照类型操作的不同，可以大致分为一下几类

- 属性修饰工具类型，对属性的修饰，包括对象属性和数组元素的`可选/必选`、`只读/可写`
- 结构工具类型，对既有类型的`裁剪、拼接、转换`
- 集合工具类型，对联合类型的处理，`交集、并集、差集、补集`
- 模式匹配工具类型，基于`infer`的模式匹配，对既有类型的特定位置类型的提取
- 模板字符串工具类型，模板字符串专属工具类型

# 属性修饰工具类型

该类型主要使用，`属性修饰、映射类型、索引类型`，内置的属性修饰工具类型有`Partial、Required、Readonly`

```ts
type Partial<T> = {
  [K in keyof T]?: T[K]
}

type Required<T> = {
  [K in keyof T]-?: T[K]
}

type Readonly<T> = {
  readonly [K in keyof T]: T[K]
}
```

`Required`的`-?`相当于在原本属性上如果有`?`，则移除`?`，这样属性就为必选了，`Partial`也可以使用`+?`显示的表示添加可选标记，`Readonly`也可以使用`+readonly`添加只读标记

**可选标记不等于修改属性为`string | undefined`**，如果声明对象的一个属性为`string | undefined`，依旧会要求提供该属性

```ts
interface Foo {
  required: string
  optional: string | undefined
}

// 报错，"Property 'optional' is missing in type '{ required: string; }' but required in type 'Foo'"
const foo1: Foo = {
  required: 'required',
}

const foo2: Foo = {
  required: 'required',
  optional: undefined,
}
```

对于结构声明来说，一个属性是否必须提供仅取决于其是否携带`可选标记`；即使使用`never`也无法标记为可选，只会导致该属性无法被赋值

# 结构工具类型

该类型主要使用，`条件类型、映射类型、索引类型`，结构工具类型又可以分为`结构声明`和`结构处理`

结构声明用于快速声明一个结构，比如内置的`Record`

```ts
type Record<T extends any, V> = {
  [K in T]: V
}
```

结构处理工具类型有`Pick、Omit`

```ts
type Pick<T, K extends keyof T> = {
  [P in K]: T[P]
}
```

`Pick`接受两个范型参数，`T`是接受范型处理的原类型（一般为对象），`K`被约束为`T类型`的键名联合类型。`Pick`的作用是将联合类型作为被选择的属性，配合映射类型，返回一个新的类型

```ts
interface Foo {
  name: string
  age: number
  male: boolean
}

type PickedFoo = Pick<Foo, 'name' | 'age'>
// { name: string, age: number }
```

`Omit`是`Pick`的反向实现，`Pick`是选择传入的键，`Omit`是剔除传入的键

```ts
type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>
```

`Omit`是基于`Partial`实现的，`Exclude`的作用是移除联合类型中的类型；这里`Exclude<keyof T, K>`就是从原对象结构的键名联合类型中，删除`K`所对应的子类型。在将剩余的类型传给`Partial`就能够实现剔除`K`对于的属性

`Pick`对于范型`K`的约束是`extends keyof T`，`Omit`对于范型`K`的却是`extends keyof any`，所以`Omit`的范型`K`不是严格约束的。如果需要严格的类型约束，可以自己实现`StrictOmit`

```ts
type StrictOmit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>
```

# 集合工具类型

该类型主要使用，`条件类型、条件类型分布式特性`

![集合](/static/images/blog/typescript/jihe.png)

- 交集，A、B两个集合相同的部分
- 并集，A、B两个集合的合并
- 差集，A对于B的差集就是，A有B没有的部分
- 补集，补集是差集的特殊情况，A对于B的补集就是，B是A的子集的情况下，A对B的差集

内置工具类型`Extract、Exclude`提供了交集与差集的实现

```ts
// 交集
type Extract<T, U> = T extends U ? T : never

// 差集
type Exclude<T, U> = T extends U ? never : T
```

具体实现就是`条件类型的分布式特性`，当`T`与`U`都是联合类型（集合）时，`T`的成员会被依次进行`extends U ? type1 : type2`比较

自定义实现并集与补集

```ts
// 并集
type Union<T | U> = T | U

// 补集
type Complemane<T, U extends T> = Exclude<T, U>
```

# 模式匹配工具类型

该类型主要使用`条件类型、infer`，`infer`代表了一种模式匹配的思路

对函数类型签名的模式匹配

```ts
type FunctionType = (...args: any) => any

// 匹配函数参数
type ParameType<T extends FunctionType> = T extends (...args: infer P) => any ? P : never

// 匹配函数返回值
type ReturnType<T extends FunctionType> = T extends (...args: any) => infer R ? R : any
```

根据`infer`位置的不同，获取不同位置的类型。还可以更进一步，只匹配第一个类型

```ts
type FunctionType = (...args: any) => any

type FirstParameType<T extends FunctionType> = T extends (firstParame: infer P, ...args: any) => any
  ? P
  : never

type FuncFoo = (arg1: number, arg2: string) => void
type FuncBar = (...args: string[]) => void

type FirstParameTypeFoo = FirstParameType<FuncFoo> // number
type FirstParameTypeBar = FirstParameType<FuncBar> // string
```

除了对函数进行模式匹配，内置工具类型中还有对类进行模式匹配的工具类型

```ts
type ClassType = abstract new (...args: any) => any

type ConstractParameType<T extends ClassType> = T extends abstract new (...args: infer P) => void
  ? P
  : never

type InstanceType<T extends ClassType> = T extends abstract new (...args: any) => infer P ? P : any
```

类的类型签名，实际上就是声明了`可实例化（new）与可抽象（abstract）`
