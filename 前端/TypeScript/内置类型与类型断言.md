# 内置类型

`any`、`unknown`、`never`

## any

`any`用于表示任意类型，除了显示标记一个变量或参数为`any`，在某些情况下，变量和参数也会被隐式推导为`any`；`any`类型几乎无所不能，它在声明后可以再次接收任意类型的值，也可以赋值给任意类型的变量

```ts
let bar // 使用let声明变量但没有赋予初始值时，变量类型会被隐式推导为any

let foo: any = 'foo'
foo = 123
foo = true
foo = [1, 2, 3]
foo = () => {}
foo = {}

const val1: string = foo
const val2: boolean = foo
```

声明为`any`类型的变量，可以认为类型检查被禁用了

## unknown

`unknown`类型与`any`类型相似，`unknown`类型可以再次赋值为其他类型，但是`unknown`类型只能赋值给`any`和`unknown`类型

```ts
let foo: unknown = 'foo'
foo = true
foo = 123
foo = () => {}

let var1: unknown = foo
let var2: string = foo // 报错，"Type 'unknown' is not assignable to type 'string'"
let var3: boolean = foo // 报错，"Type 'unknown' is not assignable to type 'boolean'"
```

`any`类型放弃了所有的类型检查，而`unknown`类型并没有

```ts
let unknownVal: unknown
unknownVal.foo() // 报错，"'unknownVal' is of type 'unknown'"

let anyVal: any
anyVal.foo() // 不报错
```

要对`unknown`类型进行访问，需要进行类型断言

## never

`never`不携带任何的类型信息，可以视为一种虚无的类型

```ts
type unionWithNever = string | number | void | never
```

![never_type](/static/images/blog/typescript/never_type.png)
根据图片的类型提示可以看到，`unionWithNever`的类型是`string | number | void`，`never`直接被无视了，但是`void`还存在；因为`void`表示**这里有类型，但是类型为空**，而`never`表示**什么都不是**的类型，或者可以认为是**没有类型**，所以在联合类型中被直接移除

`never`类型被称为`Bottom Type`，是整个类型系统层级中，最底层的类型。和`null`、`undefined`一样，是所有类型的子类型，但是`never`类型的变量只接受同为`never`类型的赋值

```ts
let v1: never
let v2: void

v1 = v2 // 报错，"Type 'void' is not assignable to type 'never'"

v2 = v1
```

`never`一般情况下并不会被使用，通常指用于类型检查，只用少数情况下会只用到`never`，比如一个抛出异常的函数

```ts
function throwError(): never {
  throw new Error()
}
```

在类型流分析中，一个返回值为`never`的函数被调用，那么后续的代码都被视为无效代码

```ts
function throwError(): never {
  throw new Error()
}

function foo(bar: boolean) {
  if (bar) {
    throwError()
    console.log('invalid code') // 报错，"Unreachable code detected"
  } else {
    console.log('bar is false')
  }
}
```

还可以使用`never`来做类型分支的判断

```ts
type StrOrNumOrBool = string | number | boolean

function typeJudgment(param: StrOrNumOrBool) {
  if (typeof param === 'string') {
    console.log('str!')
  } else if (typeof param === 'number') {
    console.log('num!')
  } else {
    throw new Error(`Unknown input type: ${param}`)
  }
}
```

上面的代码如果传入了一个`boolean`类型的变量，但是没有对应的处理`boolean`类型的`if`分支，只用当代码运行时才能够知道错误，所以可以利用`never`类型只能赋值给`never`类型的特点，当传入的参数由对应的`if`语句处理后，剩下的未处理的类型都交给`never`，那么未处理的类型都会报错

```ts
type StrOrNumOrBool = string | number | boolean

function typeJudgment(param: StrOrNumOrBool) {
  if (typeof param === 'string') {
    console.log('str!')
  } else if (typeof param === 'number') {
    console.log('num!')
  } else {
    const unhandled: never = param // 报错，"Type 'boolean' is not assignable to type 'never'"
    throw new Error(`Unknown input type: ${unhandled}`)
  }
}
```

此时，TypeScript就会提示错误，提醒我们添加对`boolean`类型的处理分支

# 类型断言

类型断言用于告知检查程序当前变量的类型，将变量已有的类型改变为新类型

```ts
// 将`any`、`unknown`断言到一个具体的类型
let unknownVar: unknown
;(unknownVar as { foo: () => {} }).foo()

// 将变量断言为any，跳过类型检查
const foo: string = 'foo'(foo as any).bar.baz()

// 在联合类型中断言到具体的类型
function foo(union: string | number) {
  if ((union as string).includes('bar')) {
    // ...
  }

  if ((union as number).toFixed() === '100') {
    // ...
  }
}
```

## 双重断言

在使用类型断言时，原类型与新类型差距过大时，TypeScript就会通过报错提示需要将原类型断言为`unknown`之后在断言为新类型

```ts
const str: string = '123'

str as number // 报错，"Conversion of type 'string' to type 'number' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first"

str as unknown as number
```

## 非空断言

非空断言使用`!`，标记前面的声明非空（剔除`null`和`undefined`）

```ts
declare const foo: {
  func?: () => {
    prop?: number | null
  }
}

foo.func().prop.toFixed()
// 报错，"Cannot invoke an object which is possibly 'undefined'"和"Object is possibly 'null' or 'undefined'"

foo.func!().prop!.toFixed() // 不报错
```

非空断言不同与`可选链`，非空断言在执行时会保存调用链，所以在执行过程中可能会报错；可选链在遇到`undefined`和`null`时会短路，不会继续调用
