范型就像函数的参数，接受一个参数，返回一个新的值；而模板字符串类型，从字面意义上看就能知道与模板字符串有关

# 模板字符串类型

```ts
type World = 'World'

type HelloWorld = `Hello ${World}`
```

这里的`HelloWorld`就是一个模板字符串类型，通过与模板字符串相同的语法`${}`，使用了另一个类型别名`World`，最终的类型就是将两个字符串类型组装在一起

模板字符串也能通过范型传入，但是只接受`string | number | boolean | null | undefined | bigint`这几个类型，并且所有传入给模板字符串类型的类型，最终都会被转换为字符串字面量类型

```ts
type Greet<T extends string | number | boolean | null | undefined | bigint> = `Hello ${T}`

type GreetStr = Greet<'foo'> // "Hello foo"
type GreetNum = Greet<599> // "Hello 599"
type GreetBool = Greet<true> // "Hello true"
type GreetNull = Greet<null> // "Hello null"
type GreetUndefined = Greet<undefined> // "Hello undefined"
type GreetBigint = Greet<0x1fffffffffffff> // "Hello 9007199254740991"
```

可以给模板字符串类型插槽直接提供一个类型

```ts
type Greeting = `Hello ${string}`
```

此时，`Greeting`的类型并不会是`"Hello string"`，而是保持原样。此时所有以`Hello `（注意Hello后的空格）开头的字符串字面量类型都是它的子类型，比如`Hello JiaX`

模板字符串的主要目的就是增强字符串字面量类型的灵活性，进一步增强类型和逻辑代码的关联，比如声明版本号

```ts
type Version = `${number}.${number}.${number}`

type v1: Version = '1.0.2'

type v2: Version = '2.0' // 报错，"Type '"1.1"' is not assignable to type '`${number}.${number}.${number}`'"
```

对于存在大量关联的字符串字面量类型，模板字符串能够在减少代码提供更好的类型保障，比如商品的`SKU`

```ts
type SKU =
  | 'iphone-16G-official'
  | 'xiaomi-16G-official'
  | 'honor-16G-official'
  | 'iphone-16G-second-hand'
  | 'xiaomi-16G-second-hand'
  | 'honor-16G-second-hand'
  | 'iphone-64G-official'
  | 'xiaomi-64G-official'
  | 'honor-64G-official'
```

如果商品以及参数的增对，就需要添加很多字面量类型，可以利用字符串字面量类型`自动分发`的特性，实现声明

```ts
type Brand = 'iphone' | 'xiaomi' | 'honor'
type Memory = '16G' | '64G'
type ItemType = 'official' | 'second-hand'

type SKU = `${Brand}-${Memory}-${ItemType}`
```

通过这种方式，会将模板字符串插槽中的联合类型与其他字符串类型依次进行排列组合，除了在插槽中传递联合类型，通过范型传入联合类型依旧有分发的过程

```ts
type SizeRecord<Size extends string> = `${Size}-Record`

type Size = 'Small' | 'Middle' | 'Large'

// "Small-Record" | "Middle-Record" | "Huge-Record"
type UnionSizeRecord = SizeRecord<Size>
```

只要插槽的类型匹配，字符串字面量类型就可以被认为是模板字符串类型的子类型

```ts
declare let v1: `${number}.${number}.${number}`
declare let v2: '1.2.4'

v1 = v2

v2 = v1 // 不成立，报错，"Type '`${number}.${number}.${number}`' is not assignable to type '"1.2.4"'"
```

# 结合索引类型与映射类型

模板字符串类型结合`keyof`，可以实现精确到字面量类型的类型推导

```ts
interface Foo {
  name: string
  age: number
  job: 'frontEnd' | 'backEnd'
}

type ChangeListener = {
  on: (Change: `${keyof Foo}Changed`) => void
}

declare let listener: ChangeListener

listener.on('') // 提供类型提示，'"nameChanged" | "ageChanged" | "jobChanged"'
```

TS针对模板字符串类型，提供了新语法`重映射`，与`映射类型`实现更好的协作，可以实现在映射键名时基于原键名做修改

```ts
// 使用映射类型复制接口
type Copy<T extends object> = {
  [K in keyof T]: T[K]
}

// 在复制的同时修改键名
type CopyAndRename<T extends object> = {
  [K in keyof T as `modified_${K & string}`]: T[K]
}

interface Foo {
  name: string
  age: number
}

type CopiedFoo = CopyAndRename<Foo>

// type CopiedFoo = {
//   modified_name: string;
//   modified_age: number;
// }
```

这里其实就是使用`as`，将映射的键名作为变量映射到一个新的字符串类型。因为对象的合法键名包括`symbol`类型，而模板字符串不接受`symbol`类型，所以插槽中使用`K & string`确保，键名为合法的`string`类型

TS提供了一些内置的工具类型用于字符串字面量类型,`Uppercase、Lowercase、Capitalize、Uncapitalize`，它们的作用分别是`字符串大写、字符串小写、首字母大写、首字母小写`

# 模板字符串类型与模式匹配

模板插槽不仅可以声明占位类型，还可以使用`infer`声明要提取的位置

```ts
type ReverseName<Str extends string> = Str extends `${infer First} ${infer Last}`
  ? `${Capitalize<Last>} ${First}`
  : Str
```

这里我们约束了传入的字符串字面量类型是`Tom Hardy`这样的英文姓名格式，空格需要严格遵循，因为空格也是字符串字面量类型的一部分。使用模板插槽结合`infer`，提取了空格两端的字符串（名和姓），在使用模板插槽注入到新的模板字符串类型中。如果传入的值是`A B C`这种有多个空格的字符串字面量类型，只会匹配第一个空格

还可以直接声明一个范型进行模式匹配操作

```ts
declare function handler<Str extends string>(arg: `Guess who is ${Str}`): Str

handler(`Guess who is Tom`) // "Tom"
handler(`Guess who is `) // ""
handler(`Guess who is  `) // " "

handler(`Guess who was`) // 报错
handler(``) // 报错
```
