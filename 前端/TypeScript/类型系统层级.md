在TypeScript中，类型层级指的是**所有类型的兼容关系，从最上层的`any`类型，到最底层的`never`类型**，上层类型能够兼容下层类型

# 判断类型兼容性的方式

以条件类型和赋值操作为例，简单判断类型的兼容性

```ts
// 条件类型
type IsStr = 'aaa' extends string ? 1 : 2

// 赋值
declare let anyType: any
declare let stringType: string
declare let neverType: never

anyType = stringType

neverType = stringType // 类型错误
```

条件类型`IsStr`如果返回`字面量类型1`说明，`'aaa` extends string'成立，则说明`aaa`为`string`的字类型。在赋值操作中，如果`变量A = 变量B`成立，就意味着`<变量B的类型> extends <变量A的类型>`成立，说明**B类型是A类型的字类型**。`string extends any`是成立的，而`string extends never`显然不成立

# 基础类型

原始类型和`object`类型

```ts
type Result1 = 'aaa' extends string ? 1 : 2 // 1
type Result2 = 1 extends number ? 1 : 2 // 1
type Result3 = true extends boolean ? 1 : 2 // 1
type Result4 = { name: string } extends object ? 1 : 2 // 1
type Result5 = { name: 'aaa' } extends object ? 1 : 2 // 1
type Result6 = [] extends object ? 1 : 2 // 1
```

原始类型的字面量类型存在父子类型关系。`object`代表所有非原始类型的类型，包括`对象、数组、函数`所以`[] extends object`才会成立

**所以字面量类型的层级低于其对应的基础类型**

# 原始类型往上

## 联合类型

在联合类型中，只要实现了其中一个类型，就认为实现了这个联合类型

```ts
type Result1 = string extends string | number ? 1 : 2 // 1
type Result2 = 'aaa' extends string | number | true ? 1 : 2 // 1

type Result3 = 'aaa' extends 'aaa' | 123 ? 1 : 2 // 1
type Result4 = string extends 'aaa' | 123 ? 1 : 2 // 2
type Result5 = 'aaa' | 123 extends string ? 1 : 2 // 2
```

**有关联合类型层级比较的几个结论**

- 字面量类型 < 包含此字面量类型的联合类型
  - `type Result = 'aaa' extends 'aaa' | 123 ? 1 : 2 // 1`
- 原始类型 < 包含此原始类型的联合类型
  - `type Result = string extends string | number ? 1 : 2 // 1`
- 同一基础类型的字面量联合类型 < 该基础类型
  - `type Result = 'aaa' | 'bbb' extends string ? 1 : 2 // 1`
  - `type Result = {} | [] | (() => void) extends object ? 1 : 2 // 1`

## 装箱类型

在JavaScript中的`装箱对象`在TypeScript的体现就是对应的`装箱类型`，在JavaScript中原型链顶端的`Object对象`在TypeScript中也有对应的`Object`类型

可以得出结论`string类型`是`String类型`的子类型，`String类型`是`Object类型`的子类型

而在`string`到`Object`之间，还有着其他的层级关系

```ts
type Result1 = string extends String ? 1 : 2 // 1
type Result2 = String extends {} ? 1 : 2 // 1
type Result3 = {} extends object ? 1 : 2 // 1
type Result4 = object extends Object ? 1 : 2 // 1
```

`{}`作为`object`的字面量类型，出现在这里显得特别的奇怪，而且`String`还是作为它的字类型。这里的原因和`结构化类型系统`有关

当我们把`String`看做一个普通对象，上面实现了一些方法`replace、replaceAll、startWith、...`；在结构化类型系统的比较下，就可以认为`String`继承了`{}`，然后自己实现了这些方法；此时`String`会被认为是`{}`的子类型

这里貌似可以构建一条类型层级链`string -> String -> {} -> object -> Object`，但是`string extends object`是不成立的，因为`object`代表所有非原始类型的类型，自然不包括`string`

由于结构化类型系统的存在，会出现一些矛盾的情况

```ts
type Result1 = {} extends object ? 1 : 2 // 1
type Result2 = object extends {} ? 1 : 2 // 1

type Result3 = Object extends {} ? 1 : 2 // 1
type Result4 = {} extends Object ? 1 : 2 // 1

type Result5 = object extends Object ? 1 : 2 // 1
type Result6 = Object extends object ? 1 : 2 // 1
```

可以发现，上面的代码出现了你是我爹，我是你爹的`共轭父子`的情况

前两组比较`Result 1、2、3、4`出现这种情况是因为，采用了完全不同的比较方式

- `{} extends object`和`{} extends Object`，是从`类型信息层面`进行比较，`{}`是`object、Object`的字面量类型，所以成立
- `object extends {}`和`Object extends {}`，是从`结构化类型系统`进行比较，`{}`最为一个什么都没有的空对象，在结构化类型系统中可以被视为`所有类型的基类（万物起源）`，所以也成立

而`object extends Object`和`Object extends object`，属于是`系统设定`的问题。`Object`包含所有除了`Top Type（any、unknown）`以外的类型；`object`包含所有`非原始类型的类型`，因此造成你中有我，我中有你的现象

**只从类型信息层面得出的结论：原始类型 < 原始类型的装箱类型 < Object类型**

# 顶层类型（Top Type）

`any`和`unknown`是顶层类型，所有类型都是它们的字类型

```ts
type Result1 = Object extends any ? 1 : 2 // 1
type Result2 = Object extends unknown ? 1 : 2 // 1
```

如果将条件类型的两端对调，就又会出现神奇的现象

```ts
type Result1 = unknown extends Object ? 1 : 2 // 2

type Result2 = any extends Object ? 1 : 2 // 1 | 2
type Result3 = any extends string | number ? // string | number
```

因为`any`代表了任何可能的类型；在使用`any extends`时，它同时包含**让条件成立的的部分和让条件不成立的部分**，条件既成立也不成立。所以条件类型判断如果接受`any`，就会返回**条件类型结果组成的联合类型**

`any`和`unknown`的比较是互相成立的

```ts
type Result1 = any extends unknown ? 1 : 2 // 1
type Result2 = unknown extends any ? 1 : 2 // 1
```

**从类型信息层面得出结论：Object < any / unknown**

# 底层类型

**`never`是所有类型的最底层：never < 字面量类型**

`never`作为范型参数传给条件类型，会直接跳过判断返回`never`

```ts
// 直接使用，会正常进行判断
type Result = never extends string ? 1 : 2 // 2

type IsString<T> = T extends string ? 1 : 2
// 通过范型参数传入，跳过判断
type Result2 = IsString<never> // never

type Result3 = never extends never ? 1 : 2 // 1
type IsNever<T> = T extends never ? 1 : 2
// 即使判断条件是never
type Result4 = IsNever<never> // never
```
