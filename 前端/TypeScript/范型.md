# 类型别名中的范型

一个类型别名如果声明了一个`范型坑位`，可以将其认为是一个“函数”，输入的范型就是`参数`

```ts
type Factory<T> = T | string | number
```

类型别名中的范型大多是用来进行工具类型的封装，比如在学习类型映射时，实现的两个工具类型

```ts
type Stringify<T> = {
  [K in keyof T]: string
}

type Clone<T> = {
  [K in keyof T]: T[K]
}
```

`Stringify`会返回一个跟输入的类型键名类型一致，但是键值类型都为`string`的类型；`Clone`这会复制一个一模一样的类型，TypeScript的内置类型`Partial`接收一个对象类型，克隆并将对象类型的所有属性设置为可选后返回，使用范型和类型别名实现

```ts
type Partial<T> = {
  [K in keyof T]?: T[k]
}
```

在范型与类型工具结合中，除了`索引类型`、`映射类型`等类型工具，还有`条件类型`，类似于`三元表达式`

```ts
type IsTrue<T> = T extends true ? T : 2

type A = IsTrue<true> // true
type B = IsTrue<false> // 2
type C = IsTrue<'bar'> // 2
```

范型可以像函数参数一样设置默认值

```ts
type Factory<T = boolean> = T | string | number
```

范型可以使用`extends`关键字做`范型约束`，`A extends B`意味着A是B的子类型，简单的判断逻辑就是`A比B的类型更精确或者更复杂`

```ts
// 字面量类型与其对应的原始类型
'aaaa' extends string
true extends boolean
0 extends number

// 联合类型子集与联合类型
string extends string | number | boolean
string | boolean extends string | number | boolean

// 更复杂
{ name: string } extends {}
// { name: string } 在 {} 的基础上添加了额外的类型，基类与派生类同理
```

具体使用案例

```ts
type ResStatus<ResCode extends number> = ResCode extends 10000 | 10001 | 10002
  ? 'success'
  : 'failure'

type Res1 = ResStatus<10000> // "success"
type Res2 = ResStatus<20000> // "failure"

type Res3 = ResStatus<'10000'> // 类型“string”不满足约束“number”。
```

# 对象类型中的范型

对象中的范型与类型别名的范型使用的概念相同，在对象结构的属性中预留出一个范型坑位，比如说一个通用的响应类型结构

```ts
interface IRes<TData = unknown> {
  code: number
  error?: string
  data: TData
}

interface IUserProfileRes {
  name: string
  homepage: string
  avatar: string
}

function fetchUserProfile(): Promise<IRes<IUserProfileRes>> {}

type StatusSucceed = boolean
function handleOperation(): Promise<IRes<StatusSucceed>> {}
```

# 函数中的范型

当有一个函数，它的参数可以有多个类型，根据参数类型的不同返回值类型也不同，可以有下面几种声明方式

```ts
// 使用any
function handle1(param: any): any {}

// 使用联合类型
function handle2(param: string | number | boolean): string | number | boolean {}

// 使用函数重载
function handle3(param: string): string
function handle3(param: number): number
function handle3(param: boolean): boolean
function handle2(param: string | number | boolean): string | number | boolean {}
```

上面的代码中，使用`any`是最糟糕的做法；而使用`联合类型`会导致返回值的类型没有与入参类型关联起来依旧是`string | number | boolean`；使用函数重载就需要声明多个重载签名。而使用范型，就能很好的解决问题

```ts
function handle<T>(param: T): T {}
```

为函数声明了一个范型`T`，并将参数与返回值的类型都指向这个范型，当传入参数时，`T`会自动填充为该参数的类型。

在基于参数类型来填充范型时，类型信息会推断到尽可能精确，当传入一个值当时候，因为值不会被修改，所有可以推导到到字面量类型；而传入一个变量时，会推导到变量的标注类型

```ts
function handle<T>(param: T): T {}

const name = 'foo' // 使用const声明，类型推导为 'foo'
let age = 18 // 使用let声明，类型推导为 number

handle(name) // 填充为字面量类型 'foo'
handle(age) // 填充为基础类型 number
handle(20) // 填充为字面量类型 20
```

函数中的范型同样可以使用默认值或者进行范型约束

```ts
// 约束类型为string或number
function handle<T extends string | number>(param: T): T {}

// 约束只接受元组类型
function swat<T extends number, K extends number>([arg1, arg2]: [T, K]): [K, T] {
  return [arg2, arg1]
}
```

函数的范型可以被内部逻辑消费

```ts
function handle<T>(payload: T): Promise<[T]> {
  return new Promise<[T]>((res, rej) => {
    res([payload])
  })
}
```

箭头函数的范型`const handle = <T>(input: T): T => {}`，在`tsx文件中`可能无法识别尖括号是范型还是组件，可以让范型更像范型一点`const handle = <T extends any>(param: T): T => {}`
