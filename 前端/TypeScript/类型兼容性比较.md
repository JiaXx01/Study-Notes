# 结构化类型系统

```ts
class Cat {
  eat() {}
}

class Dog {
  eat() {}
}

function feedCat(cat: Cat) {}

feedCat(new Dog())
```

上面的代码出现了一个奇怪的现象，函数的参数类型标注为了`Cat`，应该只能接受`Cat`的实例对象；但是代码里传入的是`Dog`的实例对象，而且没有报错。

当我们给`Cat`添加一个独有的方法

```ts
class Cat {
  eat() {}
  meow() {}
}

class Dog {
  eat() {}
}

function feedCat(cat: Cat) {}

feedCat(new Dog())
// 报错
// Argument of type 'Dog' is not assignable to parameter of type 'Cat'.
// Property 'meow' is missing in type 'Dog' but required in type 'Cat'.
```

这时就会报错，这才是我们预期中出现的现象。出现这种情况是因为TypeScript比较两个类型并非通过比较类型的名称，而是比较两个类型的属性和方法，就是根据`Cat类型`的属性和方法是否都存在于`Do类型上`

如果只单独给`Dog类型`添加一个独有的方法

```ts
class Cat {
  eat() {}
}

class Dog {
  eat() {}
  bark() {}
}

function feedCat(cat: Cat) {}

feedCat(new Dog())
```

这时候又没有类型报错了，这是因为结构化类型系统认为`Dog类型`完全实现了`Cat类型`，`Dog类`可以被认为是`Cat类`的子类

在比较对象类型的属性时，也采用结构化类型系统进行比较，对结构中的属性和方法的类型进行比较

```ts
class Cat {
  eat(): boolean {
    return true
  }
}

class Dog {
  eat(): number {
    return 599
  }
}

function feedCat(cat: Cat) {}

feedCat(new Dog())
// 报错
// Argument of type 'Dog' is not assignable to parameter of type 'Cat'.
// The types returned by 'eat()' are incompatible between these types.
// Type 'number' is not assignable to type 'boolean'
```

# 标称类型系统

标称类型系统要求，**两个可兼容的类型，其名称必须一致**

```ts
type USD = number
type CNY = number

const CNYCount: CNY = 200
const USDCount: USD = 200

function addCNY(source: CNY, input: CNY) {
  return source + input
}

addCNY(CNYCount, USDCount)
```

上面的代码并没有报错，因为在结构化类型系统中，`USD类型`和`CNY类型`被认为是两个完全一致的类型，因此在`addCNY`函数中可以传入`USD类型`的变量。在我们的认知中，这两个类型是不能视为同种类型的

在标称类型系统中，`CNY`和`USD`就是两种不同的类型。在标称类型系统中，父子类型关系只能通过显式的类型继承来实现。如何在TypeScript中实现标称类型系统呢？只需要为类型额外添加`元数据`

```ts
declare class Unit<T extends string> {
  tag: T
}

type Currency<T, U extends string> = T & Unit<U>

type CNY = Currency<number, 'CNY'>

type USD = Currency<number, 'USD'>

const CNYCount = 100 as CNY

const USDCount = 100 as USD

function addCNY(source: CNY, input: CNY) {
  return (source + input) as CNY
}

addCNY(CNYCount, CNYCount)

addCNY(CNYCount, USDCount)
// 报错
/**
Argument of type 'USD' is not assignable to parameter of type 'CNY'.
  Type 'USD' is not assignable to type 'Unit<"CNY">'.
    Types of property 'tag' are incompatible.
      Type '"USD"' is not assignable to type '"CNY"'.
**/
```

上面的代码只实现了类型安全，无法在运行时做进一步的限制，下面的代码可以从逻辑层面入手保证运行时安全

```ts
class CNY {
  private __tag!: void
  constructor(public value: number) {}
}
class USD {
  private __tag!: void
  constructor(public value: number) {}
}

const CNYCount = new CNY(100)
const USDCount = new USD(100)

function addCNY(source: CNY, input: CNY) {
  return source.value + input.value
}

addCNY(CNYCount, CNYCount)

addCNY(CNYCount, USDCount)
// 报错
/**
Argument of type 'USD' is not assignable to parameter of type 'CNY'.
  Types have separate declarations of a private property '__tag'
**/
```

**注意**，类中的`private __tag!: void`的`private`是必须的，也可以是`protected`；但是一但没有标识为`private`或`protected`，就会变成`鸭子类型`，被结构化类型系统认为是同一种类型
