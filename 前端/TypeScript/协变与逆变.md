**逆变与协变看的不是很懂，笔记有点杂乱，待后续修改**

之前学习了TypeScript类型系统中自上向下的类型层级，没有提到函数，函数的类型层级是什么样的？

在类型系统中，属性更多的类型是子类型，所以`子类型比父类型更具体`

# 函数签名类型比较

对于函数类型，要比较的其实就是`参数类型和返回值类型`

定义三个具有层级的类

```ts
class Animal {
  asPet() {}
}

// 狗
class Dog extends Animal {
  bark() {} // 狗叫
}

// 柯基
class Corgi extends Dog {
  short() {} // 短腿
}

// 泰迪
class Teddy extends Dog {
  curly() {} // 卷毛
}
```

定义一个接受`Dog`类型并返回`Dog`类型的函数类型

```ts
type DogFactory = (arg: Dog) => Dog
```

定义一个用于进行类型比较大辅助函数，这个函数接受一个类型为`(arg: Dog) => Dog`的参数

```ts
function transformDogAndBark(dogFactory: DogFactory) {}
```

在类型层级系统中讲过，**一个值如果可以被赋值给某个类型的变量，那么可以认为这个值的类型是此变量类型的子类型**，所以，如果一个函数可以作为参数传给`transformDogAndBark`，那么可以认为这个函数的类型是`(arg: Dog) => Dog`的子类型

`transformDogAndBark`会实例化一个`Dog`，并且传给`dogFactory`，然后调用`Dog`的`bark`方法；`transformDogAndBark`的调用，约束了`dogFactory`方法的参数和返回值，它会传入一只狗，什么品种不确定`(需要能够接受所有的狗)`，你需要也返回一只狗，什么品种都可以，因为只有狗才有`bark`方法

- `Animal / Dog / Corgi / Teddy => Animal`类型，返回值不是一只合法的狗
- `Corgi => Corgi`或`Corgi => Dog`类型，返回值满足了条件，但是参数类型不满足，这两个类型参数需要`Corgi`类型，可能内部需要调用`short`方法。但是传入的类型是不确定的，可能会传入`Teddy`类型，`Corgi`类型是无法接接受`Teddy`类型的
- `Animal => Corgi`、`Dog => Teddy`、`Animal => Dog`，这些类型的参数能够接受一只狗，并且返回值也是一只狗，而且一定有`bark`方法

**结论**

- 参数类型可以是`Dog类型`或`Dog类型的父类型`，不允许是`Dog类型的子类型`
- 返回值类型可以是`Dog类型`或`Dog类型的子类型`，不允许是`Dog类型的父类型`

# 逆变与协变

根据上一节定义的类型层级`Teddy / Corgi < Dog < Animal`，`A < B`表示A是B的子类型。当有函数类型`(arg: Dog) => Dog`简写`Dog => Dog`，不考虑包含`Dog`类型的情况下，只有`(arg: Animal) => Corgi`和`(arg: Animal) => Teddy`是它的子类型

以Corgi为例，`Corgi`是`Dog`的子类型，对这两个类型进行函数返回值的签名类型包装

```ts
type ReturnCorgi<T> = (arg: T) => Corgi

type ReturnDog<T> = (arg: T) => Dog
```

`(arg: T) => Corgi`是`(arg: T) => Dog`的子类型，就是说在需要狗的时候，柯基是可用的

以Dog为例，`Dog`是`Animal`的子类型，对这两个类型进行参数类型的签名类型包装

```ts
type ParameDog<T> = (arg: Dog) => T

type ParameAnimal<T> = (arg: Animal) => T
```

此时`(arg: Animal) => T`是`(arg: Dog) => T`的子类型
