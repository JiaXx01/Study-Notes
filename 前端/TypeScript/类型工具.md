# 类型别名

使用`type`关键字声明类型别名，通过类型别名对一组类型或特定类型结构进行封装，实现类型的复用

```ts
// 抽离联合类型
type StatusCode = 200 | 301 | 400 | 500 | 502
type PossibleDataTypes = string | number | (() => unknown)

const status: StatusCode = 502

// 抽离函数类型
type Handler = (e: Event) => void

const clickHandler: Handler = (e) => {}
const moveHandler: Handler = (e) => {}
const dragHandler: Handler = (e) => {}

// 声明对象类型
type ObjType = {
  name: string
  age: number
}
```

当类型别名声明自己能够接受一个`范型`，就是`工具类型`

```ts
type Factory<T> = T | number | string
```

工具类型的作用依旧是创建类型，通过接收范型参数，更灵活的创建类型。工具类型有点类似于函数，范型是入参，内部基于入参返回新的类型

```ts
type Factory<T> = T | number | string

type FactoryWithBool = Factory<boolean>

const foo: FactoryWithBool = true
```

# 交叉类型

之前学习的`联合类型（|）`只要赋值的类型符合联合类型中的一个类型，就可以认为实现了该联合类型；而`交叉类型（|）`与之相反，需要符合交叉类型中的全部类型，才可以认为实现了该交叉类型

```ts
interface Name {
  name: string
}

interface Age {
  age: number
}

type Profile = Name & Age

const profile: Profile = {
  name: 'JiaX',
  age: 18,
}
```

上面的`Profile`类型是对`Name`和`Age`两个对象类型的合并，所以`profile`对象就需要同时满足这两个对象类型的结构

对原始类似的合并，就出现和对象类型不同的情况了，对原始类型进行合并，只会得到`never`类型

```ts
type StrAndNum = string & number // never
```

使用交叉类型产生的新类型需要同时符合交叉类型所有成员的类型，对于原始类型来说，不存在既是`string`类型又是`number`类型的情况，所以就会得到`never`。这也是never这个`Bottom Type`的实际意义之一，**描述不存在的类型**

对于对象的交叉类型，其内部的同名属性同样会按照交叉类型进行合并

```ts
type Struct1 = {
  primitiveProp: string
  objectProp: {
    name: string
  }
}

type Struct2 = {
  primitiveProp: number
  objectProp: {
    age: number
  }
}

type PrimitivePropType = Composed['primitiveProp'] // never
type ObjectPropType = Composed['objectProp'] // { name: string; age: number; }
```

对于两个联合类型组成的交叉类型，需要实现两个联合类型的交集

```ts
type UnionIntersection1 = (1 | 2 | 3) & (1 | 2) // 1 | 2
type UnionIntersection2 = (string | number | symbol) & string // string
```

# 索引类型

## 索引签名类型

索引签名类型指的是，在接口或者类型别名中，快速声明一个**固定的键名类型和键值值类型**的类型结构，索引类型（`键名类型`）只能是`string`、`number`和`symbol`

```ts
// 字符串索引签名类型
interface StrIndexTypes {
  [key: string]: string
}

type StrIndexTypes = {
  [key: string]: number
}

// 数字索引签名类型
type NumIndexTypes = {
  [key: number]: number | string
}

// symbol索引签名类型
type SymbolIndexTypes = {
  [key: symbol]: string
}
```

只要实现了索引签名类型，即使还没有声明具体的属性，对该类型结构的访问都会被视为值的类型

```ts
interface StrIndexTypes {
  [key: string]: string
}

type PropType1 = StrIndexTypes['bar'] // string
type PropType2 = StrIndexTypes['foo'] // string

type NumIndexTypes {
  [key: number]: number
}
type PropType3 = NumIndexTypes[0] // number
```

当我们声明了一个`字符串索引签名类型`，在实现这个类型结构的变量中只能声明字符串类型的键名；但是在JavaScript中，使用中括号`obj[prop]`对方式访问对象时，会将`数字索引访问`转换为`字符串索引访问`，所以`obj[0]`和`obj['0']`的效果是相同的，对于`symbol`也是如此；因此在`字符串索引签名类型`中，仍然可以声明数字类型和symbol类型的键名

```ts
interface StrIndexTypes {
  [key: string]: string
}
const foo: StrIndexTypes = {
  0: '000',
  str: 'string',
  [Symbol('symbol')]: 'symbol',
}
```

索引签名类型也可以和具体的健值对类型声明并存，但此时键值对的类型需要符合索引签名类型的声明

```ts
interface StrOrBoolTypes {
  propA: number
  propB: boolean
  [key: string]: number | boolean
}
```

## 索引类型查询

索引类型查询使用`keyof`操作符，将对象中的所有键名转换为对应的字面量类型，并组合成联合类型

```ts
interface Obj {
  propA: string
  0: '000'
}

type ObjKeyTypes = keyof Obj // 'propA' | 0
```

除了在已知对象类型结构上使用`keyof`外，还可以使用`keyof any`，来产生一个联合类型，它有所有能做为对象的键值的类型组成`string | number | symbol`，**keyof的产物必定是联合类型**

## 索引类型访问

索引类型访问通过类似于访问对象属性的方式`obj[prop]`，通过键名的类型来访问对应值的类型

```ts
interface NumberRecord {
  [key: string]: number
}

type PropType = NumberRecord[string] // numb

// 字面量类型
interface Foo {
  propA: number
  propB: boolean
}

type PropAType = Foo['propA'] // number
type PropBType = Foo['propB'] // boolean
```

还可以将索引类型查询`keyof`和索引类型访问结合使用，使用字面量联合类型进行索引类型访问时，会将联合类型每个类型分支访问后的结果组装成联合类型

```ts
interface Foo {
  propA: number
  propB: boolean
  propC: string
}

type PropTypeUnion = Foo[keyof Foo] // string | number | boolean
```

在未声明索引签名类型的情况下，不能使用`RecordString[string]`这种原始类型的访问方式，只能通过键名的字面量类型进行访问

```ts
interface Foo {
  propA: string
}

type PropAType = Foo[string] // 报错，"Type 'Foo' has no matching index signature for type 'string'"
```

# 映射类型

映射类型使用`in`关键字，作用就是基于`键名`映射到`键值类型`，类似于数组的`map`方法

```ts
type Stringify<T> = {
  [K in keyof T]: string
}

interface Foo {
  propA: string
  propB: number
  propC: boolean
  propD: () => void
}

type StringifiedFoo = Stringify<Foo>

/**
此时StringifiedFoo的类型结构为
{
    propA: string;
    propB: string;
    propC: string;
    propD: string;
}
**/
```

当工具类型`Stringify`接收一个对象类型时，会使用`keyof`获得这个对象类型的键名组成的`字面量联合类型`，通过`in`进行类型映射，将联合类型的每个成员映射出来，并将其键值类型设置为`string`

一般不会需要把一个接口的索引类型都映射成`string`，既然能访问到键名的类型，那就能够访问到键值的类型，通过这个方法可以实现一个克隆接口的工具类型

```ts
type Clone<T> = {
  [K in keyof T]: T[K]
}

interface Foo {
  propA: string
  propB: number
  propC: boolean
  propD: () => void
}

type CloneFoo = Clone<Foo>
```

`Keyof T`是索引类型查询，会返回接口Foo的所有键名组成的字面量联合类型；`K in`是类型映射，映射`Keyof T`返回的联合类型；`T[K]`是类型查询，会根据`K`的映射结果，查询在`T`中对应的键值类型；`[K in keyof T]`的`[]`是索引签名类型

# 类型查询工作符

在JavaScript中，`typeof`操作符用于检查变量的类型，会返回`'string'，'number', ‘boolean', 'object'`这些值；TypeScript还新增了用于类型查询的`typeof`，这个typeof返回的是TypeScript的类型

```ts
const str = 'foo'

const obj = { name: 'bar' }

const nullVar = null
const undefinedVar = undefined

const fun = (input: string) => {
  return input.length > 10
}

type Str = typeof str // 'foo'
type Obj = typeof obj // { name: string; }
type Null = typeof nullVar // null
type Undefined = typeof undefined // undefined
type Fun = typeof fun // (input: string) => boolean
```

`typeof`除了可以在类型标注中使用，也可以在工具函数中使用

```ts
const fun = (input: string) => {
  return input.length > 10
}

// 类型标注
const fun2: typeof fun = (name) => name.length > 10

// 工具类型
type FunReturnType = ReturnType<typeof fun>
```

大部分情况下，`typeof`返回的类型就是鼠标悬浮时，类型提示推导出的类型，并且是**最窄的推导程度，精确到字面量类型级别**；在逻辑代码中使用的`typeof`一定是JavaScript的变量检查，而类型代码中的`typeof`一定是TypeScript的类型查询

# 类型守卫

TypeScript提供的强大的类型推导能力，会随着代码逻辑不断尝试缩窄类型，这被称为`类型的控制流分析`，也可以理解为类型推导

```ts
type StrOrNumOrBool = string | number | boolean

function typeHandler(param: StrOrNumOrBool) {
  if (typeof param === 'string') {
    console.log('str!')
  } else if (typeof param === 'number') {
    console.log('num!')
  } else if (typeof param === 'boolean') {
    console.log('bool')
  } else {
    const unhandled: never = param
    throw new Error(`Unknown input type: ${unhandled}`)
  }
}
```

上面的代码通过`if`语句的条件表达式进行了类型保护；告知分析流程序每个`if`语句代码块中的变量是何种类型

如果`if`语句的条件表达式被抽离出来，情况又会有所不同

```
function isString(input: unknown): boolean {
  return typeof input === 'string'
}

function typeHandler(param: string | number) {
  if (isString(param)) {
    param.replace('aaa', 'bbb')
    // 报错，"Property 'replace' does not exist on type 'string | number'.Property 'replace' does not exist on type 'number'"
  }
}
```

上面的情况中，如果`isString(param)`返回的结果为`true`，说明`param`的类型为`string`，但是在`param.replace('aaa', 'bbb')`并没有推断出string类型，而是依旧是`string | number`联合类型。造成这种情况的原因是`isString`是外部函数，内部的判断逻辑不在`typeHandler`函数中，类型控制流分析无法做到跨函数上下文进行类型信息收集

可以使用`is`关键字来显示提供类型信息，解决上面的问题

```ts
function isString(param: unknown): param is string {
  return typeof param === 'string'
}

function typeHandler(param: string | number) {
  if (isString(param)) {
    param.replace('aaa', 'bbb')
  }
}
```

此时`isString`函数就是`类型守卫`, `对于`isString`函数，不再使用`boolean`作为返回值的类型标注，而是使用`param is string`，通过`is string`指定传入的参数的预期类型，如果函数成功返回`true`，就会被`typeHandler`函数的类型控制流分析收集到

类型守卫函数并不会对判断逻辑和实际类型进行关联

```ts
function isString(input: unknown): input is number {
  return typeof input === 'string'
}
function typeHandler(param: string | number) {
  if (isString(param)) {
    // 这里会被识别为number类型
    param.replace('aaa', 'bbb') // 报错
  }
}
```

## 基于in的类型保护

在JavaScript中，通过`key in obj`的方式，判断一个key是否存在于对象或其原型链上，在TypeScript中也可以用来保护类型

```ts
interface Foo {
  foo: string
  fooOnly: boolean
  shared: number
}

interface Bar {
  bar: string
  barOnly: boolean
  shared: number
}

function handle(input: Foo | Bar) {
  if ('foo' in input) {
    input.fooOnly
  } else {
    input.barOnly
  }
}
```

上面的代码，如果使用`shared`来区分，会因为`Foo`和`Bar`的结构中都存在`shared`，所以导致在分支代码块中`input`依旧是`Foo | Bar`联合类型

像`foo`、`fooOnly`、`bar`、`barOnly`这种各类型独有的属性，被称为`可辨识属性`；而`Foo`和`Bar`这种能够通过可变式属性进行区别的类型，就称为`可辨识联合类型`

区分可辨识属性可以从结构层面、属性是否存在、甚至是同名属性的不同字面量类型

```ts
// 结构层面，一个为数组一个为数字
function ensureArray(input: number | number[]): number[] {
  if (Array.isArray(input)) {
    return input
  } else {
    return [input]
  }
}

interface Foo {
  kind: 'foo'
  diffType: string
  fooOnly: boolean
  shared: number
}

interface Bar {
  kind: 'bar'
  diffType: number
  barOnly: boolean
  shared: number
}

function handle1(input: Foo | Bar) {
  // 字面量不同
  if (input.kind === 'foo') {
    input.fooOnly
  } else {
    input.barOnly
  }
}
```

## 基于instanceof

在JavaScript中，可以通过`instanceof`判断两个对象原型级别的关系，所以可以使用`instanceof`简单判断对象是否是类的实例，来进行类型保护

```ts
class FooBase {}

class BarBase {}

class Foo extends FooBase {
  fooOnly() {}
}
class Bar extends BarBase {
  barOnly() {}
}

function handle(input: Foo | Bar) {
  if (input instanceof FooBase) {
    input.fooOnly()
  } else {
    input.barOnly()
  }
}
```

# 类型断言守卫

断言守卫在判断类型不通过时，会抛出错误

```ts
let str: any = 'aaaaaa'

function assertIsNumber(val: any): asserts val is number {
  if (typeof val !== 'number') {
    throw new Error('Not a number!')
  }
}

assertIsNumber(str)

// number 类型！
str.toFixed()
```
