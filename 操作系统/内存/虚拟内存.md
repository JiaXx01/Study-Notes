# 虚拟内存

**虚拟内存是操作系统为每个进程独立分配的一套用于访问计算机物理内存的虚拟地址**

单片机没有操作系统，在运行程序时，cpu直接操作内存的`物理地址`，所以单片机不能同时运行两个程序，因为第二个程序在一个内存地址上写入新值，会直接覆盖第一个程序在该内存地址上的值。

所以操作系统通过为每一个进程分配一个`虚拟内存`，来将进程所使用的物理内存地址分隔开。每个进程在自己的地盘里玩，互不干涉。

*操作系统会将不同进程的虚拟地址和不同内存的物理地址映射起来，虚拟地址如何落到物理地址对进程来说是透明的*

这样在运行多个程序的时候，就不会导致`物理地址`冲突了

* 进程所使用的内存地址叫做`虚拟内存地址`
* 实际存在硬件里的空间地址叫做`物理内存地址`

操作系统通过`内存分段`和`内存分页`来管理虚拟地址与物理地址之间的关系
# 内存分段

将一个程序分成若干个逻辑分段，比如：`代码分段`、`数据分段`、`栈段`、`堆段`。不同的段有着不同的属性。

分段机制的虚拟内存由`段选择因子`和`段内偏移量`组成
* `段选择因子`保存在`段寄存器`中，段选择因子中的`段号`被用作`段表`的索引
* `段表`是`虚拟地址`与`物理地址`的映射，段表保存了`段的基地址`、`段的界限`和`特权等级`
* `段内偏移量`位于`0`和`段界限`之间，通过`段基`和`段内偏移量`就能计算出物理内存地址
![[分段虚拟内存.svg]]

从上面的图片可以看出，`虚拟地址`通过`段表`与物理地址进行映射，根据当前段段`段基地址`加上`偏移量`就能找到物理内存中的地址

![[分段内存.svg]]

使用分段的方法，程序就不用关系具体的物理地址了；但是会存在`内存碎片`和`内存交换效率低`的问题
## 内存碎片

多个程序在物理内存中占据的空间可能是不连续的，这就导致实际使用的内存空间还有剩余，但是已经没有办法在运行新的程序了

![[内存碎片.svg]]
内存碎片有`内部内存碎片`和`外部内存碎片`，内存分段管理会根据段的实际需求分配内存，所以不会存在`内部内存碎片`；但是因为每个段的长度不固定，多个段未必能够恰好使用所有的内存空间，就会产生许多不连续的小物理内存，就会出现`外部内存碎片的问题`

通过`内存交换`解决`外部内存碎片的问题`

## 内存交换

将上图`应用B`的数据写到硬盘中，将它占有的内存空间释放出来；然后在从硬盘中将`应用B`的数据重新写到内存中，只不过不是写在原来的位置，而是跟在`应用A`的512MB内存的后面，这样就有一片连续的256MB的内存空间提供给`应用D`

![[分段内存交换.svg]]

Linux系统中，会从硬盘中划分出一块空间用于内存与硬盘的空间交换，叫做`Swap`空间

对于多进程的系统来说，用分段的方式很容易产生`外部内存碎片`，就不得不频繁的`swap`内存空间，但是硬盘的读取速度比内存慢太多了，这个过程就产生了性能瓶颈
# 内存分页

通过把`虚拟内存空间`和`物理内存空间`切成一段段固定大小的内存空间，这样一个连续并且大小固定的内存空间就叫做页

虚拟地址与物理地址之间通过`页表`进行映射，页表存储在内存中，通过`内存管理单元(MMU)`将虚拟内存地址转换为物理内存地址

![[内存分页.svg]]

页与页之间的内存空间是提前划分好的，并且是紧密排列的，所以不会出现内存分段那样段与段之间可能存在外部内存碎片的情况。但是，内存分页机制分配的最小单位为一页，所以即使写入的数据不足一页的大小，也会占据一页的空间。所以内存分页机制存在`内部内存碎片`的问题。

当内存空间不够时，操作系统会把正在运行的进程中`最近没被使用`的页，释放掉，将其转入硬盘中，称为`换出(Swap out)`。当需要使用时，在重新加载回来，称为`换入(Swap in)`。

![[分页内存交换.svg]]

一次性写入磁盘的只会有少数几个页，所以内存交换的效率相对较高

虚拟地址和物理地址的映射
* 虚拟地址由`页号`和`页内偏移量`组成
* `页号`作为`页表`的索引
* `页表`记录了物理页所在物理内存的`页号`
* 通过`物理页号`加上`业内偏移量`就得到了物理内存的地址

![[分页虚拟内存.svg]]

